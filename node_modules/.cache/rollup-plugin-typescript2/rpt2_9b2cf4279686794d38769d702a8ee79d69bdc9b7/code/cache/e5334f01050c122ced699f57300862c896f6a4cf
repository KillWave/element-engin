{"code":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { isCEPolyfill } from './dom.js';\r\nimport { isTemplatePartActive } from './template.js';\r\n/**\r\n * An instance of a `Template` that can be attached to the DOM and updated\r\n * with new values.\r\n */\r\nexport class TemplateInstance {\r\n    constructor(template, processor, options) {\r\n        this.__parts = [];\r\n        this.template = template;\r\n        this.processor = processor;\r\n        this.options = options;\r\n    }\r\n    update(values) {\r\n        let i = 0;\r\n        for (const part of this.__parts) {\r\n            if (part !== undefined) {\r\n                part.setValue(values[i]);\r\n            }\r\n            i++;\r\n        }\r\n        for (const part of this.__parts) {\r\n            if (part !== undefined) {\r\n                part.commit();\r\n            }\r\n        }\r\n    }\r\n    _clone() {\r\n        // There are a number of steps in the lifecycle of a template instance's\r\n        // DOM fragment:\r\n        //  1. Clone - create the instance fragment\r\n        //  2. Adopt - adopt into the main document\r\n        //  3. Process - find part markers and create parts\r\n        //  4. Upgrade - upgrade custom elements\r\n        //  5. Update - set node, attribute, property, etc., values\r\n        //  6. Connect - connect to the document. Optional and outside of this\r\n        //     method.\r\n        //\r\n        // We have a few constraints on the ordering of these steps:\r\n        //  * We need to upgrade before updating, so that property values will pass\r\n        //    through any property setters.\r\n        //  * We would like to process before upgrading so that we're sure that the\r\n        //    cloned fragment is inert and not disturbed by self-modifying DOM.\r\n        //  * We want custom elements to upgrade even in disconnected fragments.\r\n        //\r\n        // Given these constraints, with full custom elements support we would\r\n        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\r\n        //\r\n        // But Safari does not implement CustomElementRegistry#upgrade, so we\r\n        // can not implement that order and still have upgrade-before-update and\r\n        // upgrade disconnected fragments. So we instead sacrifice the\r\n        // process-before-upgrade constraint, since in Custom Elements v1 elements\r\n        // must not modify their light DOM in the constructor. We still have issues\r\n        // when co-existing with CEv0 elements like Polymer 1, and with polyfills\r\n        // that don't strictly adhere to the no-modification rule because shadow\r\n        // DOM, which may be created in the constructor, is emulated by being placed\r\n        // in the light DOM.\r\n        //\r\n        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\r\n        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\r\n        // in one step.\r\n        //\r\n        // The Custom Elements v1 polyfill supports upgrade(), so the order when\r\n        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\r\n        // Connect.\r\n        const fragment = isCEPolyfill ?\r\n            this.template.element.content.cloneNode(true) :\r\n            document.importNode(this.template.element.content, true);\r\n        const stack = [];\r\n        const parts = this.template.parts;\r\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\r\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\r\n        let partIndex = 0;\r\n        let nodeIndex = 0;\r\n        let part;\r\n        let node = walker.nextNode();\r\n        // Loop through all the nodes and parts of a template\r\n        while (partIndex < parts.length) {\r\n            part = parts[partIndex];\r\n            if (!isTemplatePartActive(part)) {\r\n                this.__parts.push(undefined);\r\n                partIndex++;\r\n                continue;\r\n            }\r\n            // Progress the tree walker until we find our next part's node.\r\n            // Note that multiple parts may share the same node (attribute parts\r\n            // on a single element), so this loop may not run at all.\r\n            while (nodeIndex < part.index) {\r\n                nodeIndex++;\r\n                if (node.nodeName === 'TEMPLATE') {\r\n                    stack.push(node);\r\n                    walker.currentNode = node.content;\r\n                }\r\n                if ((node = walker.nextNode()) === null) {\r\n                    // We've exhausted the content inside a nested template element.\r\n                    // Because we still have parts (the outer for-loop), we know:\r\n                    // - There is a template in the stack\r\n                    // - The walker will find a nextNode outside the template\r\n                    walker.currentNode = stack.pop();\r\n                    node = walker.nextNode();\r\n                }\r\n            }\r\n            // We've arrived at our part's node.\r\n            if (part.type === 'node') {\r\n                const part = this.processor.handleTextExpression(this.options);\r\n                part.insertAfterNode(node.previousSibling);\r\n                this.__parts.push(part);\r\n            }\r\n            else {\r\n                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\r\n            }\r\n            partIndex++;\r\n        }\r\n        if (isCEPolyfill) {\r\n            document.adoptNode(fragment);\r\n            customElements.upgrade(fragment);\r\n        }\r\n        return fragment;\r\n    }\r\n}\r\n","references":["C:/Users/Administrator/Desktop/lit-html/src/lit-html/dom.ts","C:/Users/Administrator/Desktop/lit-html/src/lit-html/interface/part.ts","C:/Users/Administrator/Desktop/lit-html/src/lit-html/render-options.ts","C:/Users/Administrator/Desktop/lit-html/src/lit-html/template-processor.ts","C:/Users/Administrator/Desktop/lit-html/src/lit-html/template.ts"],"dts":{"name":"C:/Users/Administrator/Desktop/lit-html/node_modules/.cache/rollup-plugin-typescript2/placeholder/lit-html/template-instance.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { RenderOptions } from './render-options.js';\r\nimport { TemplateProcessor } from './template-processor.js';\r\nimport { Template } from './template.js';\r\n/**\r\n * An instance of a `Template` that can be attached to the DOM and updated\r\n * with new values.\r\n */\r\nexport declare class TemplateInstance {\r\n    private readonly __parts;\r\n    readonly processor: TemplateProcessor;\r\n    readonly options: RenderOptions;\r\n    readonly template: Template;\r\n    constructor(template: Template, processor: TemplateProcessor, options: RenderOptions);\r\n    update(values: readonly unknown[]): void;\r\n    _clone(): DocumentFragment;\r\n}\r\n"}}

{"code":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\n/**\r\n * @module lit-html\r\n */\r\nimport { reparentNodes } from './dom.js';\r\nimport { boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker } from './template.js';\r\n// declare const trustedTypes: typeof window.trustedTypes;\r\n/**\r\n * Our TrustedTypePolicy for HTML which is declared using the html template\r\n * tag function.\r\n *\r\n * That HTML is a developer-authored constant, and is parsed with innerHTML\r\n * before any untrusted expressions have been mixed in. Therefor it is\r\n * considered safe by construction.\r\n */\r\nconst policy = window.trustedTypes &&\r\n    window.createPolicy('lit-html', { createHTML: (s) => s });\r\nconst commentMarker = ` ${marker} `;\r\n/**\r\n * The return type of `html`, which holds a Template and the values from\r\n * interpolated expressions.\r\n */\r\nexport class TemplateResult {\r\n    constructor(strings, values, type, processor) {\r\n        this.strings = strings;\r\n        this.values = values;\r\n        this.type = type;\r\n        this.processor = processor;\r\n    }\r\n    /**\r\n     * Returns a string of HTML used to create a `<template>` element.\r\n     */\r\n    getHTML() {\r\n        const l = this.strings.length - 1;\r\n        let html = '';\r\n        let isCommentBinding = false;\r\n        for (let i = 0; i < l; i++) {\r\n            const s = this.strings[i];\r\n            // For each binding we want to determine the kind of marker to insert\r\n            // into the template source before it's parsed by the browser's HTML\r\n            // parser. The marker type is based on whether the expression is in an\r\n            // attribute, text, or comment position.\r\n            //   * For node-position bindings we insert a comment with the marker\r\n            //     sentinel as its text content, like <!--{{lit-guid}}-->.\r\n            //   * For attribute bindings we insert just the marker sentinel for the\r\n            //     first binding, so that we support unquoted attribute bindings.\r\n            //     Subsequent bindings can use a comment marker because multi-binding\r\n            //     attributes must be quoted.\r\n            //   * For comment bindings we insert just the marker sentinel so we don't\r\n            //     close the comment.\r\n            //\r\n            // The following code scans the template source, but is *not* an HTML\r\n            // parser. We don't need to track the tree structure of the HTML, only\r\n            // whether a binding is inside a comment, and if not, if it appears to be\r\n            // the first binding in an attribute.\r\n            const commentOpen = s.lastIndexOf('<!--');\r\n            // We're in comment position if we have a comment open with no following\r\n            // comment close. Because <-- can appear in an attribute value there can\r\n            // be false positives.\r\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\r\n                s.indexOf('-->', commentOpen + 1) === -1;\r\n            // Check to see if we have an attribute-like sequence preceding the\r\n            // expression. This can match \"name=value\" like structures in text,\r\n            // comments, and attribute values, so there can be false-positives.\r\n            const attributeMatch = lastAttributeNameRegex.exec(s);\r\n            if (attributeMatch === null) {\r\n                // We're only in this branch if we don't have a attribute-like\r\n                // preceding sequence. For comments, this guards against unusual\r\n                // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\r\n                // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\r\n                // below.\r\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\r\n            }\r\n            else {\r\n                // For attributes we use just a marker sentinel, and also append a\r\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\r\n                // that IE and Edge do for style and certain SVG attributes.\r\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\r\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\r\n                    marker;\r\n            }\r\n        }\r\n        html += this.strings[l];\r\n        return html;\r\n    }\r\n    getTemplateElement() {\r\n        const template = document.createElement('template');\r\n        let value = this.getHTML();\r\n        if (policy !== undefined) {\r\n            // this is secure because `this.strings` is a TemplateStringsArray.\r\n            // TODO: validate this when\r\n            // https://github.com/tc39/proposal-array-is-template-object is\r\n            // implemented.\r\n            value = policy.createHTML(value);\r\n        }\r\n        template.innerHTML = value;\r\n        return template;\r\n    }\r\n}\r\n/**\r\n * A TemplateResult for SVG fragments.\r\n *\r\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\r\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\r\n * clones only container the original fragment.\r\n */\r\nexport class SVGTemplateResult extends TemplateResult {\r\n    getHTML() {\r\n        return `<svg>${super.getHTML()}</svg>`;\r\n    }\r\n    getTemplateElement() {\r\n        const template = super.getTemplateElement();\r\n        const content = template.content;\r\n        const svgElement = content.firstChild;\r\n        content.removeChild(svgElement);\r\n        reparentNodes(content, svgElement.firstChild);\r\n        return template;\r\n    }\r\n}\r\n","references":["C:/Users/Administrator/Desktop/lit-html/src/html-engin/dom.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/template-processor.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/template.ts"],"dts":{"name":"C:/Users/Administrator/Desktop/lit-html/node_modules/.cache/rollup-plugin-typescript2/placeholder/html-engin/template-result.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { TemplateProcessor } from './template-processor.js';\r\n/**\r\n * The return type of `html`, which holds a Template and the values from\r\n * interpolated expressions.\r\n */\r\nexport declare class TemplateResult {\r\n    readonly strings: TemplateStringsArray;\r\n    readonly values: readonly unknown[];\r\n    readonly type: string;\r\n    readonly processor: TemplateProcessor;\r\n    constructor(strings: TemplateStringsArray, values: readonly unknown[], type: string, processor: TemplateProcessor);\r\n    /**\r\n     * Returns a string of HTML used to create a `<template>` element.\r\n     */\r\n    getHTML(): string;\r\n    getTemplateElement(): HTMLTemplateElement;\r\n}\r\n/**\r\n * A TemplateResult for SVG fragments.\r\n *\r\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\r\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\r\n * clones only container the original fragment.\r\n */\r\nexport declare class SVGTemplateResult extends TemplateResult {\r\n    getHTML(): string;\r\n    getTemplateElement(): HTMLTemplateElement;\r\n}\r\n"}}

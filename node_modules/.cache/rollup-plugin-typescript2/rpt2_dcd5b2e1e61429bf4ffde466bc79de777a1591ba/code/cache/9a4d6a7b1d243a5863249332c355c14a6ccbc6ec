{"code":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nconst directives = new WeakMap();\r\n/**\r\n * Brands a function as a directive factory function so that lit-html will call\r\n * the function during template rendering, rather than passing as a value.\r\n *\r\n * A _directive_ is a function that takes a Part as an argument. It has the\r\n * signature: `(part: Part) => void`.\r\n *\r\n * A directive _factory_ is a function that takes arguments for data and\r\n * configuration and returns a directive. Users of directive usually refer to\r\n * the directive factory as the directive. For example, \"The repeat directive\".\r\n *\r\n * Usually a template author will invoke a directive factory in their template\r\n * with relevant arguments, which will then return a directive function.\r\n *\r\n * Here's an example of using the `repeat()` directive factory that takes an\r\n * array and a function to render an item:\r\n *\r\n * ```js\r\n * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`\r\n * ```\r\n *\r\n * When `repeat` is invoked, it returns a directive function that closes over\r\n * `items` and the template function. When the outer template is rendered, the\r\n * return directive function is called with the Part for the expression.\r\n * `repeat` then performs it's custom logic to render multiple items.\r\n *\r\n * @param f The directive factory function. Must be a function that returns a\r\n * function of the signature `(part: Part) => void`. The returned function will\r\n * be called with the part object.\r\n *\r\n * @example\r\n *\r\n * import {directive, html} from 'lit-html';\r\n *\r\n * const immutable = directive((v) => (part) => {\r\n *   if (part.value !== v) {\r\n *     part.setValue(v)\r\n *   }\r\n * });\r\n */\r\nexport const directive = (f) => ((...args) => {\r\n    const d = f(...args);\r\n    directives.set(d, true);\r\n    return d;\r\n});\r\nexport const isDirective = (o) => {\r\n    return typeof o === 'function' && directives.has(o);\r\n};\r\n","references":["C:/Users/Administrator/Desktop/lit-html/src/html-engin/part.ts"],"dts":{"name":"C:/Users/Administrator/Desktop/lit-html/node_modules/.cache/rollup-plugin-typescript2/placeholder/html-engin/directive.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { Part } from './part.js';\r\nexport declare type DirectiveFactory = (...args: any[]) => object;\r\nexport declare type DirectiveFn = (part: Part) => void;\r\n/**\r\n * Brands a function as a directive factory function so that lit-html will call\r\n * the function during template rendering, rather than passing as a value.\r\n *\r\n * A _directive_ is a function that takes a Part as an argument. It has the\r\n * signature: `(part: Part) => void`.\r\n *\r\n * A directive _factory_ is a function that takes arguments for data and\r\n * configuration and returns a directive. Users of directive usually refer to\r\n * the directive factory as the directive. For example, \"The repeat directive\".\r\n *\r\n * Usually a template author will invoke a directive factory in their template\r\n * with relevant arguments, which will then return a directive function.\r\n *\r\n * Here's an example of using the `repeat()` directive factory that takes an\r\n * array and a function to render an item:\r\n *\r\n * ```js\r\n * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`\r\n * ```\r\n *\r\n * When `repeat` is invoked, it returns a directive function that closes over\r\n * `items` and the template function. When the outer template is rendered, the\r\n * return directive function is called with the Part for the expression.\r\n * `repeat` then performs it's custom logic to render multiple items.\r\n *\r\n * @param f The directive factory function. Must be a function that returns a\r\n * function of the signature `(part: Part) => void`. The returned function will\r\n * be called with the part object.\r\n *\r\n * @example\r\n *\r\n * import {directive, html} from 'lit-html';\r\n *\r\n * const immutable = directive((v) => (part) => {\r\n *   if (part.value !== v) {\r\n *     part.setValue(v)\r\n *   }\r\n * });\r\n */\r\nexport declare const directive: <F extends DirectiveFactory>(f: F) => F;\r\nexport declare const isDirective: (o: unknown) => o is DirectiveFn;\r\n"}}

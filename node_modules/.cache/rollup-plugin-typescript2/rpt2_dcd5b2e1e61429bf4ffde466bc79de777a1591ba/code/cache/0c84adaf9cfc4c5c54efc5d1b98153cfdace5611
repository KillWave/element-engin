{"code":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { isDirective } from './directive.js';\r\nimport { removeNodes } from './dom.js';\r\nimport { noChange, nothing } from './part.js';\r\nimport { TemplateInstance } from './template-instance.js';\r\nimport { TemplateResult } from './template-result.js';\r\nimport { createMarker } from './template.js';\r\nexport const isPrimitive = (value) => {\r\n    return (value === null ||\r\n        !(typeof value === 'object' || typeof value === 'function'));\r\n};\r\nexport const isIterable = (value) => {\r\n    return Array.isArray(value) ||\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        !!(value && value[Symbol.iterator]);\r\n};\r\n/**\r\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\r\n * single attribute. The value is only set once even if there are multiple parts\r\n * for an attribute.\r\n */\r\nexport class AttributeCommitter {\r\n    constructor(element, name, strings) {\r\n        this.dirty = true;\r\n        this.element = element;\r\n        this.name = name;\r\n        this.strings = strings;\r\n        this.parts = [];\r\n        for (let i = 0; i < strings.length - 1; i++) {\r\n            this.parts[i] = this._createPart();\r\n        }\r\n    }\r\n    /**\r\n     * Creates a single part. Override this to create a differnt type of part.\r\n     */\r\n    _createPart() {\r\n        return new AttributePart(this);\r\n    }\r\n    _getValue() {\r\n        const strings = this.strings;\r\n        const l = strings.length - 1;\r\n        const parts = this.parts;\r\n        // If we're assigning an attribute via syntax like:\r\n        //    attr=\"${foo}\"  or  attr=${foo}\r\n        // but not\r\n        //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\r\n        // then we don't want to coerce the attribute value into one long\r\n        // string. Instead we want to just return the value itself directly,\r\n        // so that sanitizeDOMValue can get the actual value rather than\r\n        // String(value)\r\n        // The exception is if v is an array, in which case we do want to smash\r\n        // it together into a string without calling String() on the array.\r\n        //\r\n        // This also allows trusted values (when using TrustedTypes) being\r\n        // assigned to DOM sinks without being stringified in the process.\r\n        if (l === 1 && strings[0] === '' && strings[1] === '') {\r\n            const v = parts[0].value;\r\n            if (typeof v === 'symbol') {\r\n                return String(v);\r\n            }\r\n            if (typeof v === 'string' || !isIterable(v)) {\r\n                return v;\r\n            }\r\n        }\r\n        let text = '';\r\n        for (let i = 0; i < l; i++) {\r\n            text += strings[i];\r\n            const part = parts[i];\r\n            if (part !== undefined) {\r\n                const v = part.value;\r\n                if (isPrimitive(v) || !isIterable(v)) {\r\n                    text += typeof v === 'string' ? v : String(v);\r\n                }\r\n                else {\r\n                    for (const t of v) {\r\n                        text += typeof t === 'string' ? t : String(t);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        text += strings[l];\r\n        return text;\r\n    }\r\n    commit() {\r\n        if (this.dirty) {\r\n            this.dirty = false;\r\n            this.element.setAttribute(this.name, this._getValue());\r\n        }\r\n    }\r\n}\r\n/**\r\n * A Part that controls all or part of an attribute value.\r\n */\r\nexport class AttributePart {\r\n    constructor(committer) {\r\n        this.value = undefined;\r\n        this.committer = committer;\r\n    }\r\n    setValue(value) {\r\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\r\n            this.value = value;\r\n            // If the value is a not a directive, dirty the committer so that it'll\r\n            // call setAttribute. If the value is a directive, it'll dirty the\r\n            // committer if it calls setValue().\r\n            if (!isDirective(value)) {\r\n                this.committer.dirty = true;\r\n            }\r\n        }\r\n    }\r\n    commit() {\r\n        while (isDirective(this.value)) {\r\n            const directive = this.value;\r\n            this.value = noChange;\r\n            directive(this);\r\n        }\r\n        if (this.value === noChange) {\r\n            return;\r\n        }\r\n        this.committer.commit();\r\n    }\r\n}\r\n/**\r\n * A Part that controls a location within a Node tree. Like a Range, NodePart\r\n * has start and end locations and can set and update the Nodes between those\r\n * locations.\r\n *\r\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\r\n * as well as arrays and iterables of those types.\r\n */\r\nexport class NodePart {\r\n    constructor(options) {\r\n        this.value = undefined;\r\n        this.__pendingValue = undefined;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Appends this part into a container.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    appendInto(container) {\r\n        this.startNode = container.appendChild(createMarker());\r\n        this.endNode = container.appendChild(createMarker());\r\n    }\r\n    /**\r\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\r\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\r\n     * such as those that appear in a literal section of a template.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    insertAfterNode(ref) {\r\n        this.startNode = ref;\r\n        this.endNode = ref.nextSibling;\r\n    }\r\n    /**\r\n     * Appends this part into a parent part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    appendIntoPart(part) {\r\n        part.__insert(this.startNode = createMarker());\r\n        part.__insert(this.endNode = createMarker());\r\n    }\r\n    /**\r\n     * Inserts this part after the `ref` part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    insertAfterPart(ref) {\r\n        ref.__insert(this.startNode = createMarker());\r\n        this.endNode = ref.endNode;\r\n        ref.endNode = this.startNode;\r\n    }\r\n    setValue(value) {\r\n        this.__pendingValue = value;\r\n    }\r\n    commit() {\r\n        if (this.startNode.parentNode === null) {\r\n            return;\r\n        }\r\n        while (isDirective(this.__pendingValue)) {\r\n            const directive = this.__pendingValue;\r\n            this.__pendingValue = noChange;\r\n            directive(this);\r\n        }\r\n        const value = this.__pendingValue;\r\n        if (value === noChange) {\r\n            return;\r\n        }\r\n        if (isPrimitive(value)) {\r\n            if (value !== this.value) {\r\n                this.__commitText(value);\r\n            }\r\n        }\r\n        else if (value instanceof TemplateResult) {\r\n            this.__commitTemplateResult(value);\r\n        }\r\n        else if (value instanceof Node) {\r\n            this.__commitNode(value);\r\n        }\r\n        else if (isIterable(value)) {\r\n            this.__commitIterable(value);\r\n        }\r\n        else if (value === nothing) {\r\n            this.value = nothing;\r\n            this.clear();\r\n        }\r\n        else {\r\n            // Fallback, will render the string representation\r\n            this.__commitText(value);\r\n        }\r\n    }\r\n    __insert(node) {\r\n        this.endNode.parentNode.insertBefore(node, this.endNode);\r\n    }\r\n    __commitNode(value) {\r\n        if (this.value === value) {\r\n            return;\r\n        }\r\n        this.clear();\r\n        this.__insert(value);\r\n        this.value = value;\r\n    }\r\n    __commitText(value) {\r\n        const node = this.startNode.nextSibling;\r\n        value = value == null ? '' : value;\r\n        // If `value` isn't already a string, we explicitly convert it here in case\r\n        // it can't be implicitly converted - i.e. it's a symbol.\r\n        const valueAsString = typeof value === 'string' ? value : String(value);\r\n        if (node === this.endNode.previousSibling &&\r\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\r\n            // If we only have a single text node between the markers, we can just\r\n            // set its value, rather than replacing it.\r\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\r\n            node.data = valueAsString;\r\n        }\r\n        else {\r\n            this.__commitNode(document.createTextNode(valueAsString));\r\n        }\r\n        this.value = value;\r\n    }\r\n    __commitTemplateResult(value) {\r\n        const template = this.options.templateFactory(value);\r\n        if (this.value instanceof TemplateInstance &&\r\n            this.value.template === template) {\r\n            this.value.update(value.values);\r\n        }\r\n        else {\r\n            // Make sure we propagate the template processor from the TemplateResult\r\n            // so that we use its syntax extension, etc. The template factory comes\r\n            // from the render function options so that it can control template\r\n            // caching and preprocessing.\r\n            const instance = new TemplateInstance(template, value.processor, this.options);\r\n            const fragment = instance._clone();\r\n            instance.update(value.values);\r\n            this.__commitNode(fragment);\r\n            this.value = instance;\r\n        }\r\n    }\r\n    __commitIterable(value) {\r\n        // For an Iterable, we create a new InstancePart per item, then set its\r\n        // value to the item. This is a little bit of overhead for every item in\r\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\r\n        // of TemplateResults that will be commonly returned from expressions like:\r\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\r\n        // If _value is an array, then the previous render was of an\r\n        // iterable and _value will contain the NodeParts from the previous\r\n        // render. If _value is not an array, clear this part and make a new\r\n        // array for NodeParts.\r\n        if (!Array.isArray(this.value)) {\r\n            this.value = [];\r\n            this.clear();\r\n        }\r\n        // Lets us keep track of how many items we stamped so we can clear leftover\r\n        // items from a previous render\r\n        const itemParts = this.value;\r\n        let partIndex = 0;\r\n        let itemPart;\r\n        for (const item of value) {\r\n            // Try to reuse an existing part\r\n            itemPart = itemParts[partIndex];\r\n            // If no existing part, create a new one\r\n            if (itemPart === undefined) {\r\n                itemPart = new NodePart(this.options);\r\n                itemParts.push(itemPart);\r\n                if (partIndex === 0) {\r\n                    itemPart.appendIntoPart(this);\r\n                }\r\n                else {\r\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\r\n                }\r\n            }\r\n            itemPart.setValue(item);\r\n            itemPart.commit();\r\n            partIndex++;\r\n        }\r\n        if (partIndex < itemParts.length) {\r\n            // Truncate the parts array so _value reflects the current state\r\n            itemParts.length = partIndex;\r\n            this.clear(itemPart && itemPart.endNode);\r\n        }\r\n    }\r\n    clear(startNode = this.startNode) {\r\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\r\n    }\r\n}\r\n/**\r\n * Implements a boolean attribute, roughly as defined in the HTML\r\n * specification.\r\n *\r\n * If the value is truthy, then the attribute is present with a value of\r\n * ''. If the value is falsey, the attribute is removed.\r\n */\r\nexport class BooleanAttributePart {\r\n    constructor(element, name, strings) {\r\n        this.value = undefined;\r\n        this.__pendingValue = undefined;\r\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\r\n            throw new Error('Boolean attributes can only contain a single expression');\r\n        }\r\n        this.element = element;\r\n        this.name = name;\r\n        this.strings = strings;\r\n    }\r\n    setValue(value) {\r\n        this.__pendingValue = value;\r\n    }\r\n    commit() {\r\n        while (isDirective(this.__pendingValue)) {\r\n            const directive = this.__pendingValue;\r\n            this.__pendingValue = noChange;\r\n            directive(this);\r\n        }\r\n        if (this.__pendingValue === noChange) {\r\n            return;\r\n        }\r\n        const value = !!this.__pendingValue;\r\n        if (this.value !== value) {\r\n            if (value) {\r\n                this.element.setAttribute(this.name, '');\r\n            }\r\n            else {\r\n                this.element.removeAttribute(this.name);\r\n            }\r\n            this.value = value;\r\n        }\r\n        this.__pendingValue = noChange;\r\n    }\r\n}\r\n/**\r\n * Sets attribute values for PropertyParts, so that the value is only set once\r\n * even if there are multiple parts for a property.\r\n *\r\n * If an expression controls the whole property value, then the value is simply\r\n * assigned to the property under control. If there are string literals or\r\n * multiple expressions, then the strings are expressions are interpolated into\r\n * a string first.\r\n */\r\nexport class PropertyCommitter extends AttributeCommitter {\r\n    constructor(element, name, strings) {\r\n        super(element, name, strings);\r\n        this.single =\r\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\r\n    }\r\n    _createPart() {\r\n        return new PropertyPart(this);\r\n    }\r\n    _getValue() {\r\n        if (this.single) {\r\n            return this.parts[0].value;\r\n        }\r\n        return super._getValue();\r\n    }\r\n    commit() {\r\n        if (this.dirty) {\r\n            this.dirty = false;\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            this.element[this.name] = this._getValue();\r\n        }\r\n    }\r\n}\r\nexport class PropertyPart extends AttributePart {\r\n}\r\n// Detect event listener options support. If the `capture` property is read\r\n// from the options object, then options are supported. If not, then the third\r\n// argument to add/removeEventListener is interpreted as the boolean capture\r\n// value so we should only pass the `capture` property.\r\nlet eventOptionsSupported = false;\r\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\r\n// blocks right into the body of a module\r\n(() => {\r\n    try {\r\n        const options = {\r\n            get capture() {\r\n                eventOptionsSupported = true;\r\n                return false;\r\n            }\r\n        };\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        window.addEventListener('test', options, options);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        window.removeEventListener('test', options, options);\r\n    }\r\n    catch (_e) {\r\n        // event options not supported\r\n    }\r\n})();\r\nexport class EventPart {\r\n    constructor(element, eventName, eventContext) {\r\n        this.value = undefined;\r\n        this.__pendingValue = undefined;\r\n        this.element = element;\r\n        this.eventName = eventName;\r\n        this.eventContext = eventContext;\r\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\r\n    }\r\n    setValue(value) {\r\n        this.__pendingValue = value;\r\n    }\r\n    commit() {\r\n        while (isDirective(this.__pendingValue)) {\r\n            const directive = this.__pendingValue;\r\n            this.__pendingValue = noChange;\r\n            directive(this);\r\n        }\r\n        if (this.__pendingValue === noChange) {\r\n            return;\r\n        }\r\n        const newListener = this.__pendingValue;\r\n        const oldListener = this.value;\r\n        const shouldRemoveListener = newListener == null ||\r\n            oldListener != null &&\r\n                (newListener.capture !== oldListener.capture ||\r\n                    newListener.once !== oldListener.once ||\r\n                    newListener.passive !== oldListener.passive);\r\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\r\n        if (shouldRemoveListener) {\r\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\r\n        }\r\n        if (shouldAddListener) {\r\n            this.__options = getOptions(newListener);\r\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\r\n        }\r\n        this.value = newListener;\r\n        this.__pendingValue = noChange;\r\n    }\r\n    handleEvent(event) {\r\n        if (typeof this.value === 'function') {\r\n            this.value.call(this.eventContext || this.element, event);\r\n        }\r\n        else {\r\n            this.value.handleEvent(event);\r\n        }\r\n    }\r\n}\r\n// We copy options because of the inconsistent behavior of browsers when reading\r\n// the third argument of add/removeEventListener. IE11 doesn't support options\r\n// at all. Chrome 41 only reads `capture` if the argument is an object.\r\nconst getOptions = (o) => o &&\r\n    (eventOptionsSupported ?\r\n        { capture: o.capture, passive: o.passive, once: o.once } :\r\n        o.capture);\r\n","references":["C:/Users/Administrator/Desktop/lit-html/src/html-engin/directive.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/dom.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/part.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/render-options.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/template-instance.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/template-result.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/template.ts"],"dts":{"name":"C:/Users/Administrator/Desktop/lit-html/node_modules/.cache/rollup-plugin-typescript2/placeholder/html-engin/parts.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { Part } from './part.js';\r\nimport { RenderOptions } from './render-options.js';\r\nexport declare type Primitive = null | undefined | boolean | number | string | symbol | bigint;\r\nexport declare const isPrimitive: (value: unknown) => value is Primitive;\r\nexport declare const isIterable: (value: unknown) => value is Iterable<unknown>;\r\n/**\r\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\r\n * single attribute. The value is only set once even if there are multiple parts\r\n * for an attribute.\r\n */\r\nexport declare class AttributeCommitter {\r\n    readonly element: Element;\r\n    readonly name: string;\r\n    readonly strings: ReadonlyArray<string>;\r\n    readonly parts: ReadonlyArray<AttributePart>;\r\n    dirty: boolean;\r\n    constructor(element: Element, name: string, strings: ReadonlyArray<string>);\r\n    /**\r\n     * Creates a single part. Override this to create a differnt type of part.\r\n     */\r\n    protected _createPart(): AttributePart;\r\n    protected _getValue(): unknown;\r\n    commit(): void;\r\n}\r\n/**\r\n * A Part that controls all or part of an attribute value.\r\n */\r\nexport declare class AttributePart implements Part {\r\n    readonly committer: AttributeCommitter;\r\n    value: unknown;\r\n    constructor(committer: AttributeCommitter);\r\n    setValue(value: unknown): void;\r\n    commit(): void;\r\n}\r\n/**\r\n * A Part that controls a location within a Node tree. Like a Range, NodePart\r\n * has start and end locations and can set and update the Nodes between those\r\n * locations.\r\n *\r\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\r\n * as well as arrays and iterables of those types.\r\n */\r\nexport declare class NodePart implements Part {\r\n    readonly options: RenderOptions;\r\n    startNode: Node;\r\n    endNode: Node;\r\n    value: unknown;\r\n    private __pendingValue;\r\n    constructor(options: RenderOptions);\r\n    /**\r\n     * Appends this part into a container.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    appendInto(container: Node): void;\r\n    /**\r\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\r\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\r\n     * such as those that appear in a literal section of a template.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    insertAfterNode(ref: Node): void;\r\n    /**\r\n     * Appends this part into a parent part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    appendIntoPart(part: NodePart): void;\r\n    /**\r\n     * Inserts this part after the `ref` part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    insertAfterPart(ref: NodePart): void;\r\n    setValue(value: unknown): void;\r\n    commit(): void;\r\n    private __insert;\r\n    private __commitNode;\r\n    private __commitText;\r\n    private __commitTemplateResult;\r\n    private __commitIterable;\r\n    clear(startNode?: Node): void;\r\n}\r\n/**\r\n * Implements a boolean attribute, roughly as defined in the HTML\r\n * specification.\r\n *\r\n * If the value is truthy, then the attribute is present with a value of\r\n * ''. If the value is falsey, the attribute is removed.\r\n */\r\nexport declare class BooleanAttributePart implements Part {\r\n    readonly element: Element;\r\n    readonly name: string;\r\n    readonly strings: readonly string[];\r\n    value: unknown;\r\n    private __pendingValue;\r\n    constructor(element: Element, name: string, strings: readonly string[]);\r\n    setValue(value: unknown): void;\r\n    commit(): void;\r\n}\r\n/**\r\n * Sets attribute values for PropertyParts, so that the value is only set once\r\n * even if there are multiple parts for a property.\r\n *\r\n * If an expression controls the whole property value, then the value is simply\r\n * assigned to the property under control. If there are string literals or\r\n * multiple expressions, then the strings are expressions are interpolated into\r\n * a string first.\r\n */\r\nexport declare class PropertyCommitter extends AttributeCommitter {\r\n    readonly single: boolean;\r\n    constructor(element: Element, name: string, strings: ReadonlyArray<string>);\r\n    protected _createPart(): PropertyPart;\r\n    protected _getValue(): unknown;\r\n    commit(): void;\r\n}\r\nexport declare class PropertyPart extends AttributePart {\r\n}\r\ndeclare type EventHandlerWithOptions = EventListenerOrEventListenerObject & Partial<AddEventListenerOptions>;\r\nexport declare class EventPart implements Part {\r\n    readonly element: Element;\r\n    readonly eventName: string;\r\n    readonly eventContext?: EventTarget;\r\n    value: undefined | EventHandlerWithOptions;\r\n    private __options?;\r\n    private __pendingValue;\r\n    private readonly __boundHandleEvent;\r\n    constructor(element: Element, eventName: string, eventContext?: EventTarget);\r\n    setValue(value: undefined | EventHandlerWithOptions): void;\r\n    commit(): void;\r\n    handleEvent(event: Event): void;\r\n}\r\nexport {};\r\n"}}

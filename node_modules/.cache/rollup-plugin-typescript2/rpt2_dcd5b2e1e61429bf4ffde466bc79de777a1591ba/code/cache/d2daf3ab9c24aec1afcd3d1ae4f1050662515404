{"code":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { marker, Template } from './template.js';\r\n/**\r\n * The default TemplateFactory which caches Templates keyed on\r\n * result.type and result.strings.\r\n */\r\nexport function templateFactory(result) {\r\n    let templateCache = templateCaches.get(result.type);\r\n    if (templateCache === undefined) {\r\n        templateCache = {\r\n            stringsArray: new WeakMap(),\r\n            keyString: new Map()\r\n        };\r\n        templateCaches.set(result.type, templateCache);\r\n    }\r\n    let template = templateCache.stringsArray.get(result.strings);\r\n    if (template !== undefined) {\r\n        return template;\r\n    }\r\n    // If the TemplateStringsArray is new, generate a key from the strings\r\n    // This key is shared between all templates with identical content\r\n    const key = result.strings.join(marker);\r\n    // Check if we already have a Template for this key\r\n    template = templateCache.keyString.get(key);\r\n    if (template === undefined) {\r\n        // If we have not seen this key before, create a new Template\r\n        template = new Template(result, result.getTemplateElement());\r\n        // Cache the Template for this key\r\n        templateCache.keyString.set(key, template);\r\n    }\r\n    // Cache all future queries for this TemplateStringsArray\r\n    templateCache.stringsArray.set(result.strings, template);\r\n    return template;\r\n}\r\nexport const templateCaches = new Map();\r\n","references":["C:/Users/Administrator/Desktop/lit-html/src/html-engin/template-result.ts","C:/Users/Administrator/Desktop/lit-html/src/html-engin/template.ts"],"dts":{"name":"C:/Users/Administrator/Desktop/lit-html/node_modules/.cache/rollup-plugin-typescript2/placeholder/html-engin/template-factory.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { TemplateResult } from './template-result.js';\r\nimport { Template } from './template.js';\r\n/**\r\n * A function type that creates a Template from a TemplateResult.\r\n *\r\n * This is a hook into the template-creation process for rendering that\r\n * requires some modification of templates before they're used, like ShadyCSS,\r\n * which must add classes to elements and remove styles.\r\n *\r\n * Templates should be cached as aggressively as possible, so that many\r\n * TemplateResults produced from the same expression only do the work of\r\n * creating the Template the first time.\r\n *\r\n * Templates are usually cached by TemplateResult.strings and\r\n * TemplateResult.type, but may be cached by other keys if this function\r\n * modifies the template.\r\n *\r\n * Note that currently TemplateFactories must not add, remove, or reorder\r\n * expressions, because there is no way to describe such a modification\r\n * to render() so that values are interpolated to the correct place in the\r\n * template instances.\r\n */\r\nexport declare type TemplateFactory = (result: TemplateResult) => Template;\r\n/**\r\n * The default TemplateFactory which caches Templates keyed on\r\n * result.type and result.strings.\r\n */\r\nexport declare function templateFactory(result: TemplateResult): Template;\r\n/**\r\n * The first argument to JS template tags retain identity across multiple\r\n * calls to a tag for the same literal, so we can cache work done per literal\r\n * in a Map.\r\n *\r\n * Safari currently has a bug which occasionally breaks this behavior, so we\r\n * need to cache the Template at two levels. We first cache the\r\n * TemplateStringsArray, and if that fails, we cache a key constructed by\r\n * joining the strings array.\r\n */\r\nexport interface TemplateCache {\r\n    readonly stringsArray: WeakMap<TemplateStringsArray, Template>;\r\n    readonly keyString: Map<string, Template>;\r\n}\r\nexport declare const templateCaches: Map<string, TemplateCache>;\r\n"}}

{"code":"import { boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker } from './template';\r\nimport { reparentNodes } from './dom.js';\r\n//标记\r\nconst commentMarker = ` ${marker} `;\r\n//防止xss\r\nconst policy = window.trustedTypes &&\r\n    window.trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });\r\nexport class TemplateResult {\r\n    constructor(strings, values, type, processor) {\r\n        this.strings = strings;\r\n        this.values = values;\r\n        this.type = type;\r\n        this.processor = processor;\r\n    }\r\n    /**\r\n     * Returns a string of HTML used to create a `<template>` element.\r\n     */\r\n    getHTML() {\r\n        const l = this.strings.length - 1;\r\n        let html = '';\r\n        let isCommentBinding = false;\r\n        for (let i = 0; i < l; i++) {\r\n            const s = this.strings[i];\r\n            const commentOpen = s.lastIndexOf('<!--');\r\n            // We're in comment position if we have a comment open with no following\r\n            // comment close. Because <-- can appear in an attribute value there can\r\n            // be false positives.\r\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\r\n                s.indexOf('-->', commentOpen + 1) === -1;\r\n            // Check to see if we have an attribute-like sequence preceding the\r\n            // expression. This can match \"name=value\" like structures in text,\r\n            // comments, and attribute values, so there can be false-positives.\r\n            const attributeMatch = lastAttributeNameRegex.exec(s);\r\n            if (attributeMatch === null) {\r\n                // We're only in this branch if we don't have a attribute-like\r\n                // preceding sequence. For comments, this guards against unusual\r\n                // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\r\n                // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\r\n                // below.\r\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\r\n            }\r\n            else {\r\n                // For attributes we use just a marker sentinel, and also append a\r\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\r\n                // that IE and Edge do for style and certain SVG attributes.\r\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\r\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\r\n                    marker;\r\n            }\r\n        }\r\n        html += this.strings[l];\r\n        return html;\r\n    }\r\n    getTemplateElement() {\r\n        const template = document.createElement('template');\r\n        let value = this.getHTML();\r\n        if (policy !== undefined) {\r\n            // this is secure because `this.strings` is a TemplateStringsArray.\r\n            // TODO: validate this when\r\n            // https://github.com/tc39/proposal-array-is-template-object is\r\n            // implemented.\r\n            value = policy.createHTML(value);\r\n        }\r\n        template.innerHTML = value;\r\n        return template;\r\n    }\r\n}\r\nexport class SVGTemplateResult extends TemplateResult {\r\n    getHTML() {\r\n        return `<svg>${super.getHTML()}</svg>`;\r\n    }\r\n    getTemplateElement() {\r\n        const template = super.getTemplateElement();\r\n        const content = template.content;\r\n        const svgElement = content.firstChild;\r\n        content.removeChild(svgElement);\r\n        reparentNodes(content, svgElement.firstChild);\r\n        return template;\r\n    }\r\n}\r\n","references":["C:/Users/Administrator/Desktop/lit-html/src/lit-html/template.ts","C:/Users/Administrator/Desktop/lit-html/src/lit-html/template-processor.ts","C:/Users/Administrator/Desktop/lit-html/src/lit-html/dom.ts"],"dts":{"name":"C:/Users/Administrator/Desktop/lit-html/node_modules/.cache/rollup-plugin-typescript2/placeholder/lit-html/template-result.d.ts","writeByteOrderMark":false,"text":"import { TemplateProcessor } from './template-processor.js';\r\nexport declare class TemplateResult {\r\n    readonly strings: TemplateStringsArray;\r\n    readonly values: readonly unknown[];\r\n    readonly type: string;\r\n    readonly processor: TemplateProcessor;\r\n    constructor(strings: TemplateStringsArray, values: readonly unknown[], type: string, processor: TemplateProcessor);\r\n    /**\r\n     * Returns a string of HTML used to create a `<template>` element.\r\n     */\r\n    getHTML(): string;\r\n    getTemplateElement(): HTMLTemplateElement;\r\n}\r\nexport declare class SVGTemplateResult extends TemplateResult {\r\n    getHTML(): string;\r\n    getTemplateElement(): HTMLTemplateElement;\r\n}\r\n"}}

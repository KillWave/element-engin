{"code":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\n/**\r\n * An expression marker with embedded unique key to avoid collision with\r\n * possible text in templates.\r\n */\r\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\r\n/**\r\n * An expression marker used text-positions, multi-binding attributes, and\r\n * attributes with markup-like text values.\r\n */\r\nexport const nodeMarker = `<!--${marker}-->`;\r\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\r\n/**\r\n * Suffix appended to all bound attribute names.\r\n */\r\nexport const boundAttributeSuffix = '$lit$';\r\n/**\r\n * An updatable Template that tracks the location of dynamic parts.\r\n */\r\nexport class Template {\r\n    constructor(result, element) {\r\n        this.parts = [];\r\n        this.element = element;\r\n        const nodesToRemove = [];\r\n        const stack = [];\r\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\r\n        console.log(element.content);\r\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\r\n        // Keeps track of the last index associated with a part. We try to delete\r\n        // unnecessary nodes, but we never want to associate two different parts\r\n        // to the same index. They must have a constant node between.\r\n        let lastPartIndex = 0;\r\n        let index = -1;\r\n        let partIndex = 0;\r\n        const { strings, values: { length } } = result;\r\n        while (partIndex < length) {\r\n            const node = walker.nextNode();\r\n            if (node === null) {\r\n                // We've exhausted the content inside a nested template element.\r\n                // Because we still have parts (the outer for-loop), we know:\r\n                // - There is a template in the stack\r\n                // - The walker will find a nextNode outside the template\r\n                walker.currentNode = stack.pop();\r\n                continue;\r\n            }\r\n            index++;\r\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\r\n                if (node.hasAttributes()) {\r\n                    const attributes = node.attributes;\r\n                    const { length } = attributes;\r\n                    // Per\r\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\r\n                    // attributes are not guaranteed to be returned in document order.\r\n                    // In particular, Edge/IE can return them out of order, so we cannot\r\n                    // assume a correspondence between part index and attribute index.\r\n                    let count = 0;\r\n                    for (let i = 0; i < length; i++) {\r\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\r\n                            count++;\r\n                        }\r\n                    }\r\n                    while (count-- > 0) {\r\n                        // Get the template literal section leading up to the first\r\n                        // expression in this attribute\r\n                        const stringForPart = strings[partIndex];\r\n                        // Find the attribute name\r\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\r\n                        // Find the corresponding attribute\r\n                        // All bound attributes have had a suffix added in\r\n                        // TemplateResult#getHTML to opt out of special attribute\r\n                        // handling. To look up the attribute value we also need to add\r\n                        // the suffix.\r\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\r\n                        const attributeValue = node.getAttribute(attributeLookupName);\r\n                        node.removeAttribute(attributeLookupName);\r\n                        const statics = attributeValue.split(markerRegex);\r\n                        this.parts.push({ type: 'attribute', index, name, strings: statics });\r\n                        partIndex += statics.length - 1;\r\n                    }\r\n                }\r\n                if (node.tagName === 'TEMPLATE') {\r\n                    stack.push(node);\r\n                    walker.currentNode = node.content;\r\n                }\r\n            }\r\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\r\n                const data = node.data;\r\n                if (data.indexOf(marker) >= 0) {\r\n                    const parent = node.parentNode;\r\n                    const strings = data.split(markerRegex);\r\n                    const lastIndex = strings.length - 1;\r\n                    // Generate a new text node for each literal section\r\n                    // These nodes are also used as the markers for node parts\r\n                    for (let i = 0; i < lastIndex; i++) {\r\n                        let insert;\r\n                        let s = strings[i];\r\n                        if (s === '') {\r\n                            insert = createMarker();\r\n                        }\r\n                        else {\r\n                            const match = lastAttributeNameRegex.exec(s);\r\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\r\n                                s = s.slice(0, match.index) + match[1] +\r\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\r\n                            }\r\n                            insert = document.createTextNode(s);\r\n                        }\r\n                        parent.insertBefore(insert, node);\r\n                        this.parts.push({ type: 'node', index: ++index });\r\n                    }\r\n                    // If there's no text, we must insert a comment to mark our place.\r\n                    // Else, we can trust it will stick around after cloning.\r\n                    if (strings[lastIndex] === '') {\r\n                        parent.insertBefore(createMarker(), node);\r\n                        nodesToRemove.push(node);\r\n                    }\r\n                    else {\r\n                        node.data = strings[lastIndex];\r\n                    }\r\n                    // We have a part for each match found\r\n                    partIndex += lastIndex;\r\n                }\r\n            }\r\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\r\n                if (node.data === marker) {\r\n                    const parent = node.parentNode;\r\n                    // Add a new marker node to be the startNode of the Part if any of\r\n                    // the following are true:\r\n                    //  * We don't have a previousSibling\r\n                    //  * The previousSibling is already the start of a previous part\r\n                    if (node.previousSibling === null || index === lastPartIndex) {\r\n                        index++;\r\n                        parent.insertBefore(createMarker(), node);\r\n                    }\r\n                    lastPartIndex = index;\r\n                    this.parts.push({ type: 'node', index });\r\n                    // If we don't have a nextSibling, keep this node so we have an end.\r\n                    // Else, we can remove it to save future costs.\r\n                    if (node.nextSibling === null) {\r\n                        node.data = '';\r\n                    }\r\n                    else {\r\n                        nodesToRemove.push(node);\r\n                        index--;\r\n                    }\r\n                    partIndex++;\r\n                }\r\n                else {\r\n                    let i = -1;\r\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\r\n                        // Comment node has a binding marker inside, make an inactive part\r\n                        // The binding won't work, but subsequent bindings will\r\n                        // TODO (justinfagnani): consider whether it's even worth it to\r\n                        // make bindings in comments work\r\n                        this.parts.push({ type: 'node', index: -1 });\r\n                        partIndex++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\r\n        for (const n of nodesToRemove) {\r\n            n.parentNode.removeChild(n);\r\n        }\r\n    }\r\n}\r\nconst endsWith = (str, suffix) => {\r\n    const index = str.length - suffix.length;\r\n    return index >= 0 && str.slice(index) === suffix;\r\n};\r\nexport const isTemplatePartActive = (part) => part.index !== -1;\r\n// Allows `document.createComment('')` to be renamed for a\r\n// small manual size-savings.\r\nexport const createMarker = () => document.createComment('');\r\n/**\r\n * This regex extracts the attribute name preceding an attribute-position\r\n * expression. It does this by matching the syntax allowed for attributes\r\n * against the string literal directly preceding the expression, assuming that\r\n * the expression is in an attribute-value position.\r\n *\r\n * See attributes in the HTML spec:\r\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\r\n *\r\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\r\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\r\n *\r\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\r\n * space character except \" \".\r\n *\r\n * So an attribute is:\r\n *  * The name: any character except a control character, space character, ('),\r\n *    (\"), \">\", \"=\", or \"/\"\r\n *  * Followed by zero or more space characters\r\n *  * Followed by \"=\"\r\n *  * Followed by zero or more space characters\r\n *  * Followed by:\r\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\r\n *    * (\") then any non-(\"), or\r\n *    * (') then any non-(')\r\n */\r\nexport const lastAttributeNameRegex = \r\n// eslint-disable-next-line no-control-regex\r\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\r\n","references":["C:/Users/Administrator/Desktop/lit-html/src/lit-html/template-result.ts"],"dts":{"name":"C:/Users/Administrator/Desktop/lit-html/node_modules/.cache/rollup-plugin-typescript2/placeholder/lit-html/template.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { TemplateResult } from './template-result.js';\r\n/**\r\n * An expression marker with embedded unique key to avoid collision with\r\n * possible text in templates.\r\n */\r\nexport declare const marker: string;\r\n/**\r\n * An expression marker used text-positions, multi-binding attributes, and\r\n * attributes with markup-like text values.\r\n */\r\nexport declare const nodeMarker: string;\r\nexport declare const markerRegex: RegExp;\r\n/**\r\n * Suffix appended to all bound attribute names.\r\n */\r\nexport declare const boundAttributeSuffix = \"$lit$\";\r\n/**\r\n * An updatable Template that tracks the location of dynamic parts.\r\n */\r\nexport declare class Template {\r\n    readonly parts: TemplatePart[];\r\n    readonly element: HTMLTemplateElement;\r\n    constructor(result: TemplateResult, element: HTMLTemplateElement);\r\n}\r\n/**\r\n * A placeholder for a dynamic expression in an HTML template.\r\n *\r\n * There are two built-in part types: AttributePart and NodePart. NodeParts\r\n * always represent a single dynamic expression, while AttributeParts may\r\n * represent as many expressions are contained in the attribute.\r\n *\r\n * A Template's parts are mutable, so parts can be replaced or modified\r\n * (possibly to implement different template semantics). The contract is that\r\n * parts can only be replaced, not removed, added or reordered, and parts must\r\n * always consume the correct number of values in their `update()` method.\r\n *\r\n * TODO(justinfagnani): That requirement is a little fragile. A\r\n * TemplateInstance could instead be more careful about which values it gives\r\n * to Part.update().\r\n */\r\nexport declare type TemplatePart = {\r\n    readonly type: 'node';\r\n    index: number;\r\n} | {\r\n    readonly type: 'attribute';\r\n    index: number;\r\n    readonly name: string;\r\n    readonly strings: ReadonlyArray<string>;\r\n};\r\nexport declare const isTemplatePartActive: (part: TemplatePart) => boolean;\r\nexport declare const createMarker: () => Comment;\r\n/**\r\n * This regex extracts the attribute name preceding an attribute-position\r\n * expression. It does this by matching the syntax allowed for attributes\r\n * against the string literal directly preceding the expression, assuming that\r\n * the expression is in an attribute-value position.\r\n *\r\n * See attributes in the HTML spec:\r\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\r\n *\r\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\r\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\r\n *\r\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\r\n * space character except \" \".\r\n *\r\n * So an attribute is:\r\n *  * The name: any character except a control character, space character, ('),\r\n *    (\"), \">\", \"=\", or \"/\"\r\n *  * Followed by zero or more space characters\r\n *  * Followed by \"=\"\r\n *  * Followed by zero or more space characters\r\n *  * Followed by:\r\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\r\n *    * (\") then any non-(\"), or\r\n *    * (') then any non-(')\r\n */\r\nexport declare const lastAttributeNameRegex: RegExp;\r\n"}}
